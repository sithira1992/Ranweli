angular.module("ui.autocomplete", []).directive("uiAutocomplete", ["$timeout", "$exceptionHandler", function ($timeout, $exceptionHandler) {
    var proto = $.ui.autocomplete.prototype, initSource = proto._initSource; function filter(array, term) { var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i"); return $.grep(array, function (value) { return matcher.test($("<div>").html(value.label || value.value || value).text()) }) } $.extend(proto, {
        _initSource: function () {
            if (this.options.html && $.isArray(this.options.source)) this.source =
            function (request, response) { response(filter(this.options.source, request.term)) }; else initSource.call(this)
        }, _normalize: function (items) { return $.map(items, function (item) { if (item && typeof item === "object") return $.extend({ label: item.label || item.value, value: item.value || item.label }, item); else return { label: item + "", value: item } }) }, _renderItemData: function (ul, item) {
            var element = item.groupLabel || item.label; if (item.groupLabel) element = $("<div>").append(element).addClass("ui-menu-group"); else if (this.options.html) {
                if (typeof element ===
                "object") element = $(element); if (typeof element !== "object" || element.length > 1 || !element.is("a")) element = $("<a>").append(element)
            } else element = $("<a>").text(element); return $("<li>").append(element).appendTo(ul).data("ui-autocomplete-item", item)
        }, _resizeMenu: function () {
            var that = this; setTimeout(function () {
                var ul = that.menu.element; var maxHeight = ul.css("max-height") || 0, width = Math.max(ul.width("").outerWidth() + 1, that.element.outerWidth()), oHeight = that.element.height(), height = $(window).height() - that.options.outHeight -
                ul.offset().top; height = maxHeight && height > maxHeight ? maxHeight : height; ul.css({ width: width, maxHeight: height })
            }, 10)
        }
    }); return {
        require: "ngModel", link: function (scope, element, attr, ctrl) {
            var status = false, selectItem = null, events = {}, ngModel = null, each = angular.forEach, isObject = angular.isObject, extend = angular.extend, autocomplete = scope.$eval(attr.uiAutocomplete), valueMethod = angular.bind(element, element.val), methodsName = ["close", "destroy", "disable", "enable", "option", "search", "widget"], eventsName = ["change", "close",
            "create", "focus", "open", "response", "search", "select"]; var unregisterWatchModel = scope.$watch(attr.ngModel, function (value) { ngModel = value; if (isObject(ngModel)) { ctrl.$formatters.push(function (obj) { return obj.value }); ctrl.$parsers.push(function (value) { ngModel.value = value; return ngModel }); scope.$watch(attr.ngModel, function (model) { if (valueMethod() !== model.value) { ctrl.$viewValue = model.value; ctrl.$render() } }, true); ctrl.$pristine = false; ctrl.$setViewValue(ngModel.value); ctrl.$pristine = true } if (value) unregisterWatchModel() });
            var uiEvents = {
                open: function (event, ui) { status = true; selectItem = null }, close: function (event, ui) { status = false }, select: function (event, ui) { selectItem = ui; $timeout(function () { element.blur() }, 0) }, change: function (event, ui) {
                    var value = valueMethod(); if (!selectItem || !selectItem.item) value = autocomplete.options.onlySelect ? "" : value; else value = selectItem.item.value; if (value === null) ctrl.$render(); else if (ctrl.$viewValue === "") scope.$apply(function () { changeNgModel() }); else if (ctrl.$viewValue !== value) scope.$apply(function () {
                        ctrl.$setViewValue(value);
                        ctrl.$render(); changeNgModel(selectItem)
                    })
                }
            }; function changeNgModel(data) { if (isObject(ngModel)) { if (!ctrl.$viewValue && ctrl.$viewValue !== 0) emptyObj(ngModel); else if (data && data.item) { data.item.label = isObject(data.item.label) ? $("<div>").append(data.item.label).html() : data.item.label; extend(ngModel, data.item) } each(ctrl.$viewChangeListeners, function (listener) { try { listener() } catch (e) { $exceptionHandler(e) } }) } } function cleanNgModel() { ctrl.$setViewValue(""); ctrl.$render(); changeNgModel() } function autoFocusHandler() {
                if (autocomplete.options.focusOpen &&
                !status) element.autocomplete("search", "")
            } function checkOptions(options) { options = isObject(options) ? options : {}; options.disabled = options.source ? options.disabled : true; options.appendTo = options.appendTo || element.parents(".ng-view")[0] || element.parents("[ng-view]")[0] || null; options.minLength = options.focusOpen ? 0 : options.minLength; options.outHeight = options.outHeight || 0; options.position = options.position || { my: "left top", at: "left bottom", collision: "flipfit" }; return options } function emptyObj(a) {
                if (isObject(a)) {
                    var reg =
                    /^\$/; each(a, function (value, key) { var type = typeof value; if (reg.test(key)) return; else if (type === "number") a[key] = 0; else if (type === "string") a[key] = ""; else if (type === "boolean") a[key] = false; else if (isObject(value)) emptyObj(value) })
                }
            } if (!isObject(autocomplete)) return; autocomplete.methods = {}; autocomplete.options = checkOptions(autocomplete.options); each(eventsName, function (name) {
                var _event = autocomplete.options[name]; _event = typeof _event === "function" ? _event : angular.noop; events[name] = function (event, ui) {
                    if (uiEvents[name]) uiEvents[name](event,
                    ui); _event(event, ui); if (autocomplete.events && typeof autocomplete.events[name] === "function") autocomplete.events[name](event, ui)
                }
            }); each(methodsName, function (name) { autocomplete.methods[name] = function () { var args = [name]; each(arguments, function (value) { args.push(value) }); return element.autocomplete.apply(element, args) } }); autocomplete.methods.filter = filter; autocomplete.methods.clean = cleanNgModel; element.on("focus", autoFocusHandler); element.autocomplete(extend({}, autocomplete.options, events)); autocomplete.widget =
            element.autocomplete("widget")
        }
    }
}]);